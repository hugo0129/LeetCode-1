[toc]

```java
class Solution {
    public List<String> mostVisitedPattern(String[] username, int[] timestamp, String[] website) {
        List<String> res = new LinkedList<>();
        if(username == null || username.length < 3) {
            return res;
        }
        // 索引数组
        Integer[] idx = new Integer[username.length];
        for (int i = 0; i < idx.length; i++) {
            idx[i] = i;
        }
        // 根据用户id和时间戳排序
        Arrays.sort(idx, (a, b) -> username[a].compareTo(username[b]) == 0 ?
                timestamp[a] - timestamp[b] : username[a].compareTo(username[b]));
        // 创建路径map，注意值为集合，由于一个用户可能存在多条访问路径相同，使用用户集合还不是计数
        Map<String, Set<String>> counter = new HashMap<>();
        // 记录最大计数
        int maxCount = 0;
        // 记录计数相同，字典序列较小的路径
        String minOrder = website[idx[0]] + "#" + website[idx[1]] + "#" + website[idx[2]];;
        int cur = 0, next, last;
        while (cur < idx.length - 2) {
            next = cur + 1;
            // 同一个用户
            while (next < idx.length - 1 && username[idx[cur]].equals(username[idx[next]])) {
                last = next + 1;
                while (last < idx.length && username[idx[cur]].equals(username[idx[last]])) {
                    // 当前路径
                    String path = website[idx[cur]] + "#" + website[idx[next]] + "#" + website[idx[last]];
                    Set<String> temp = counter.getOrDefault(path, new HashSet<>());
                    // 加入用户
                    temp.add(username[idx[cur]]);
                    counter.put(path, temp);
                    // 统计用户，数目大则赋予新值
                    if (counter.get(path).size() > maxCount) {
                        maxCount = counter.get(path).size();
                        minOrder = path;
                    }
                    // 数目一致则判断字典序
                    else if (counter.get(path).size() == maxCount) {
                        minOrder = path.compareTo(minOrder) < 0 ? path : minOrder;
                    }
                    last++;
                }
                next++;
            }
            cur++;
        }
        res = Arrays.asList(minOrder.split("#"));
        return res;
    }
}
```
