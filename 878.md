[toc]

```java
class Solution {
    public int nthMagicalNumber(int N, int A, int B) {
        int mod = 1_000_000_007;
        // 最小公倍数Least Common Multiple
        int lcm = A * B / greatestCommonDivisor1(A, B);
        // 最小公倍数是第L个神奇数
        int L = lcm / A + lcm / B - 1;
        int t = N / L, h = N % L;

        // 由于公倍数的性质，第t×L个神奇数就是t*lcm，而N = t*L+h，只需找到第h个神奇数叠加即是答案
        long temp = (long)lcm * t;
        if(h != 0) {
            // 迭代生成h+1个神奇数（初始两个数，更新h-1次，最后得到的两个数就是第h和第h+1个神奇数）
            int num1 = A, num2 = B;
            for (int i = 0; i < h - 1; i++) {
                if(num1 < num2) num1 += A;
                else num2 += B;
            }
            // 第h个神奇数就是两个中较小的那个
            temp += Math.min(num1, num2);
        }
        // 取余
        return (int)(temp % mod);
    }

    // 最大公约数，欧几里得法（辗转相余）递归形式
    private int greatestCommonDivisor(int x, int y) {
        if(x == 0) return y;
        return greatestCommonDivisor(y % x, x);
    }
    // 非递归形式
    private int greatestCommonDivisor1(int x, int y) {
        int temp;
        while(x != 0) {
            temp = x;
            x = y % x;
            y = temp;
        }
        return y;
    }
}
```





```java
class Solution {
    public int nthMagicalNumber(int N, int A, int B) {
        int mod = 1_000_000_007;
        // 最小公倍数Least Common Multiple
        int lcm = A * B / greatestCommonDivisor(A, B);
        long low = 1, high = 400_000_000_000_000L;
        while (low < high) {
            long mid = low + (high - low) / 2;
            if(mid / A + mid / B - mid / lcm >= N) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return (int)(low % mod);
    }

    // 最大公约数，欧几里得法（辗转相余）递归形式
    private int greatestCommonDivisor(int x, int y) {
        if(x == 0) return y;
        return greatestCommonDivisor(y % x, x);
    }
}
```

