[toc]

```java
class Solution {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        if (startTime == null || startTime.length != endTime.length || startTime.length != profit.length) throw new IllegalArgumentException("invalid param");
        int jobs = startTime.length;
        // 动态规划数组，记录截止当前结束时间最大的收入
        int[] dp = new int[jobs];
        // 索引数组
        Integer[] idx = new Integer[jobs];
        for (int i = 0; i < jobs; i++) {
            idx[i] = i;
        }
        // 根据结束时间排序
        Arrays.sort(idx, (a, b) -> endTime[a] - endTime[b]);

        for (int i = 0; i < jobs; i++) {
            int start = startTime[idx[i]];

            int left = 0, right = i;
            // 二分查找第一个大于start的结束时间（即其前面小于等于开始时间）
            while (left < right) {
                int mid = left + (right - left) / 2;
                // 结束时间大于当前开始时间，继续向前搜索，右边界保持大于开始时间的第一个结束时间
                if (endTime[idx[mid]] > start) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            // left为0，表示所有结束时间都大于当前开始时间
            if (left == 0) {
                // 如果当前结束时间是最小的，则目前为止最大的收入为当前工作，否则为当前工作和之前结束时间收入的最大值
                dp[i] = i == 0 ? profit[idx[i]] : Math.max(profit[idx[i]], dp[i - 1]);
            } else {
                // 截止目前最大收入为前一时刻和当前工作加开始时间前最大收入中的最大值
                dp[i] = Math.max(dp[left - 1] + profit[idx[i]], dp[i - 1]);
            }
        }
        // 返回最大值
        return dp[jobs - 1];
    }
}
```
