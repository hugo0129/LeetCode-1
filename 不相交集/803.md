[toc]

```java
class Solution {
    public int[] hitBricks(int[][] grid, int[][] hits) {
        if(grid == null || grid.length == 0) {
            return new int[hits.length];
        }
        int col = grid.length, row = grid[0].length;
        // 移除待删除点，标识为-1
        for(int[] hit : hits) {
            if(grid[hit[0]][hit[1]] == 1) grid[hit[0]][hit[1]] = -1;
        }
        // 不相交集（设置0为连通顶部的点集合）
        DisJoint disJoint = new DisJoint(col * row + 1);
        for(int c = 0; c < col; c++) {
            for (int r = 0; r < row; r++) {
                if(grid[c][r] == 1) {
                    int idx = c * row + r + 1;
                    // 顶部元素，与边界合并
                    if(r == 0) {
                        disJoint.union(disJoint.find(0), disJoint.find(idx));
                    }
                    // 前面元素
                    if(c - 1 >= 0 && grid[c - 1][r] == 1) {
                        disJoint.union(disJoint.find(idx - row), disJoint.find(idx));
                    }
                    // 顶部元素
                    if(r - 1 >= 0 && grid[c][r - 1] == 1) {
                        disJoint.union(disJoint.find(idx - 1), disJoint.find(idx));
                    }
                }
            }
        }
        int t = hits.length - 1;
        int[] res = new int[hits.length];
        // 记录边界集合砖的数目
        int pre = disJoint.getTreeSize(0);
        while (t >= 0) {
            int c = hits[t][0], r = hits[t][1], idx = c * row + r + 1;
            // 当前点本来没有砖，不会有砖掉落
            if(grid[c][r] == 0) {
                res[t] = 0;
            } else {
                // 加入当前消除点
                grid[c][r] = 1;
                // 如果当前点是顶部砖，加入
                if(r == 0) {
                    disJoint.union(disJoint.find(0), disJoint.find(idx));
                }
                // 维护前后左右的集合
                // 前后元素
                if(c - 1 >= 0 && grid[c - 1][r] == 1) {
                    disJoint.union(disJoint.find(idx - row), disJoint.find(idx));
                }
                if(c + 1 < col && grid[c + 1][r] == 1) {
                    disJoint.union(disJoint.find(idx + row), disJoint.find(idx));
                }
                // 上下元素
                if(r - 1 >= 0 && grid[c][r - 1] == 1) {
                    disJoint.union(disJoint.find(idx - 1), disJoint.find(idx));
                }
                if(r + 1 < row && grid[c][r + 1] == 1) {
                    disJoint.union(disJoint.find(idx + 1), disJoint.find(idx));
                }

                // 如果边界集合增加了，还需要减去当前消除的结点
                res[t] = disJoint.getTreeSize(0) - pre > 0 ? disJoint.getTreeSize(0) - pre - 1 : 0;
            }
            pre = disJoint.getTreeSize(0);
            t--;
        }
        return res;
    }
}

class DisJoint {
    private int size;
    private int[] tree;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        Arrays.fill(tree, -1);
    }

    public void union(int root1, int root2) {
        if(tree[root1] >= 0 || tree[root2] >= 0) throw new IllegalArgumentException("not a root");
        if(root1 == root2) return;

        if(tree[root1] <= tree[root2]) {
            tree[root1] += tree[root2];
            tree[root2] = root1;
        } else {
            tree[root2] += tree[root1];
            tree[root1] = root2;
        }
        size--;
    }

    public int find(int idx) {
        if(tree[idx] < 0) return idx;
        return tree[idx] = find(tree[idx]);
    }

    public int size() {
        return size;
    }

    public int getTreeSize(int idx) {
        return -tree[find(idx)];
    }
}
```
