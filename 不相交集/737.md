[toc]

```java
class Solution {
    public boolean areSentencesSimilarTwo(String[] words1, String[] words2, List<List<String>> pairs) {
        if(pairs == null || pairs.size() == 0) return false;
        if(words1 == null || words2 == null || words1.length != words2.length) return false;
        // 维护单词、索引映射对
        Map<String, Integer> idxMap = new HashMap<>();
        DisJoint disJoint = new DisJoint(pairs.size() * 2);
        int idx = 0;
        for(List<String> pair : pairs) {
            if(idxMap.get(pair.get(0)) == null) idxMap.put(pair.get(0), idx++);
            if(idxMap.get(pair.get(1)) == null) idxMap.put(pair.get(1), idx++);
            // 关联
            disJoint.union(disJoint.find(idxMap.get(pair.get(0))), disJoint.find(idxMap.get(pair.get(1))));
        }
        for (int i = 0; i < words1.length; i++) {
            // 如果当前单词相等，则继续（不管是否在相近词表中存在）
            if(words1[i].equals(words2[i])) continue;
            // 查看是否在相近词表存在
            if(idxMap.get(words1[i]) == null || idxMap.get(words2[i]) == null) return false;
            // 查看是否相近
            if(disJoint.find(idxMap.get(words1[i])) != disJoint.find(idxMap.get(words2[i]))) return false;
        }
        return true;
    }
}

class DisJoint {
    private int size;
    private int[] tree;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        Arrays.fill(tree, -1);
    }

    public void union(int root1, int root2) {
        if(tree[root1] >= 0 && tree[root2] >= 0) throw new IllegalArgumentException("root must be negative");
        if(root1 == root2) return;
        if(tree[root1] <= tree[root2]) {
            tree[root1] += tree[root2];
            tree[root2] = root1;
        } else {
            tree[root2] += tree[root1];
            tree[root1] = root2;
        }
        size--;
    }

    public int find(int idx) {
        if(tree[idx] < 0) return idx;
        return tree[idx] = find(tree[idx]);
    }

    public int size() {
        return size;
    }
}
```
