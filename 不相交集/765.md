[toc]

```java
class Solution {
    public int minSwapsCouples(int[] row) {
       if(row == null || row.length < 2) {
           return 0;
       }
       if(row.length % 2 == 1) throw new IllegalArgumentException("invalid array length");
       int pair = row.length / 2;
       DisJoint disJoint = new DisJoint(row.length);
       for(int i = 0; i < row.length; i += 2) {
           // 集合加入当前对
           disJoint.union(disJoint.find(row[i]), disJoint.find(row[i + 1]));
           // 偶数则加入其后继奇数
           // 如果当前对有效，如2,3，则此处加入的还是2,3；如果无效，如1,2，则会加入3，表示需要和包含3的对做一次交换
           // 如果是0,4这种个情况，则会加入1,5表示对包含1或5的对做两次交换，对同时包含1、5的对做一次交换
           if(row[i] % 2 == 0) {
               disJoint.union(disJoint.find(row[i]), disJoint.find(row[i] + 1));
           }
           if(row[i + 1] % 2 == 0) {
               disJoint.union(disJoint.find(row[i + 1]), disJoint.find(row[i + 1] + 1));
           }
       }
       // 最后的每个不相交集表示交换情侣的连锁操作，这个集合的内部元素可以形成有效情侣对。如包含0,1,4,5的集合，最终需要形成的集合是0,1;4,5
       // 而最优交换可以每次将不相交集分裂出来一个，则最优操作数就是最后的集合数目减去初始的集合数目
       return pair - disJoint.size();
    }
}

class DisJoint {
    private int size;
    private int[] tree;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        // 初始化为size个不相交集
        for(int i = 0; i < size; i++) {
            tree[i] = -1;
        }
    }
    // 按规模并
    public void union(int root1, int root2) {
        if(tree[root1] >= 0 || tree[root2] >= 0) {
            throw new IllegalArgumentException("not a root");
        }
        if(root1 == root2) {
            return;
        }
        // 树2大，树1并入树2
        if(tree[root1] >= tree[root2]) {
            tree[root2] += tree[root1];
            tree[root1] = root2;
        } else {
            tree[root1] += tree[root2];
            tree[root2] = root1;
        }
        size--;
    }
    // 路径压缩
    public int find(int val) {
        if(tree[val] < 0) {
            return val;
        }
        return tree[val] = find(tree[val]);
    }

    public int size() {
        return size;
    }
}
```
