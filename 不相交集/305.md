[toc]

```java
class Solution {
    public List<Integer> numIslands2(int m, int n, int[][] positions) {
        List<Integer> res = new LinkedList<>();
        if(m == 0 || n == 0 || positions == null || positions.length == 0) {
            return res;
        }
        // 水的数目
        int count = m * n;
        boolean[][] island = new boolean[m][n];
        DisJoint disJoint = new DisJoint(count);
        for(int[] cur : positions) {
            int x = cur[0], y = cur[1];
            int idx = x * n + y;
            // 避免重复点操作导致计数重复减少
            if(!island[x][y]) {
                count--;
            }
            island[x][y] = true;
            // 检查前后，如果是陆地，则合并
            if(y - 1 >= 0 && island[x][y - 1]) {
                disJoint.union(disJoint.find(idx - 1), disJoint.find(idx));
            }
            if(y + 1 < n && island[x][y + 1]) {
                disJoint.union(disJoint.find(idx + 1), disJoint.find(idx));
            }
            // 检查上下，如果是陆地，则合并
            if(x - 1 >= 0 && island[x - 1][y]) {
                disJoint.union(disJoint.find(idx - n), disJoint.find(idx));
            }
            if(x + 1 < m && island[x + 1][y]) {
                disJoint.union(disJoint.find(idx + n), disJoint.find(idx));
            }
            // 添加当前岛屿数
            res.add(disJoint.size() - count);
        }
        return res;
    }
}

class DisJoint {
    private int[] tree;
    private int size;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        // 填充-1
        Arrays.fill(tree, -1);
    }

    public void union(int root1, int root2) {
        if(tree[root1] >= 0 || tree[root2] >= 0) throw new IllegalArgumentException("root must be negative");
        if(root1 == root2) return;
        if(tree[root1] < tree[root2]) {
            tree[root1] += tree[root2];
            tree[root2] = root1;
        } else {
            tree[root2] += tree[root1];
            tree[root1] = root2;
        }
        size--;
    }

    public int find(int idx) {
        if(tree[idx] < 0) return idx;
        return tree[idx] = find(tree[idx]);
    }

    public int size() {
        return size;
    }
}
```
