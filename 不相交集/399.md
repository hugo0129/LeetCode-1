[toc]

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        if(equations == null || equations.size() != values.length) {
            throw new IllegalArgumentException("invalid param");
        }
        // 记录字符和索引映射
        Map<String, Integer> idxMap = new HashMap<>();
        int idx = 0;
        // 元素的数目不超过表达式的两倍
        DisJoint disJoint = new DisJoint(2 * values.length);
        // 遍历表达式，合并计算
        for(int i = 0; i < values.length; i++) {
            String num1 = equations.get(i).get(0);
            if(idxMap.get(num1) == null) idxMap.put(num1, idx++);
            String num2 = equations.get(i).get(1);
            if(idxMap.get(num2) == null) idxMap.put(num2, idx++);
            // 维护商
            disJoint.union(idxMap.get(num1), idxMap.get(num2), values[i]);
        }
        double[] res = new double[queries.size()];
        for(int i = 0; i < res.length; i++) {
            // 不存在的变量，返回-1
            String num1 = queries.get(i).get(0);
            if(idxMap.get(num1) == null) {
                res[i] = -1.0D;
                continue;
            }
            String num2 = queries.get(i).get(1);
            if(idxMap.get(num2) == null) {
                res[i] = -1.0D;
                continue;
            }
            // 计算
            res[i] = disJoint.calcuResult(idxMap.get(num1), idxMap.get(num2));

        }
        return res;
    }
}

class DisJoint {
    private int[] tree;
    // 记录与父节点的商
    private double[] result;
    private int size;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        this.result = new double[size];
        // 填充-1
        Arrays.fill(tree, -1);
        // 商初始填充1
        Arrays.fill(result, 1.0D);
    }
    // 合并两个数（转化为合并根及两个根的商）
    public void union(int num1, int num2, double val) {
        int root1 = find(num1);
        int root2 = find(num2);
        // roo1/num1的值
        double d1 = calcuRoot(num1);
        // root2/num2的值
        double d2 = calcuRoot(num2);
        // 将树2合并到树1
        if(tree[root1] <= tree[root2]) {
            tree[root1] += tree[root2];
            tree[root2] = root1;
            // root1/root2 = d1 * num1/d2 * num2
            result[root2] = d1 / d2 * val;
        } else {
            tree[root2] += tree[root1];
            tree[root1] = root2;
            // root2/root1 = d2 * num2/d1 * num1
            result[root1] = d2 / d1 / val;
        }
        size--;
    }
    // 路径压缩
    public int find(int idx) {
        if(tree[idx] < 0) return idx;
        // 重新计算（由于路径压缩会改变父节点，在压缩前重新计算路径上的乘积）
        result[idx] = calcuRoot(idx);
        return tree[idx] = find(tree[idx]);
    }
    // 计算两数之商
    public double calcuResult(int num1, int num2) {
        // 不连通
        if(find(num1) != find(num2)) {
            return -1.0D;
        }
        // r1 = root/num1,r2 = root/num2 -> num1/num2 = r2/r1
        double r1 = calcuRoot(num1);
        double r2 = calcuRoot(num2);
        return r2 / r1;
    }
    // 计算根节点到当前值的商
    private double calcuRoot(int num) {
        if(tree[num] < 0) return result[num];
        return result[num] * calcuRoot(tree[num]);
    }

    public int size() {
        return size;
    }
}
```
