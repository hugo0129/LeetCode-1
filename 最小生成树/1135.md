[toc]

```java
class Solution {
    public int minimumCost(int N, int[][] connections) {
        // 无合法或组不成树
        if (N <= 0 || connections.length < N - 1) return -1;
        // 优先级队列，根据边的权重排序
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        for (int[] connection : connections) {
            queue.add(connection);
        }
        // 不相交集
        DisJoint disJoint = new DisJoint(N);
        // 接收的边，成本
        int accept = 0, weight = 0;
        while (accept < N - 1 && !queue.isEmpty()) {
            int[] cur = queue.poll();
            if (disJoint.find(cur[0] - 1) != disJoint.find(cur[1] - 1)) {
                disJoint.union(disJoint.find(cur[0] - 1), disJoint.find(cur[1] - 1));
                weight += cur[2];
                accept++;
            }
        }
        // 判断是否连通
        return disJoint.size() == 1 ? weight : -1;
    }
}

class DisJoint {
    private int[] tree;
    private int size;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        Arrays.fill(tree, -1);
    }

    public void union(int root1, int root2) {
        if (tree[root1] >= 0 || tree[root2] >= 0) throw new IllegalArgumentException("invalid param");
        if (root1 == root2) return;

        if (tree[root1] <= tree[root2]) {
            tree[root1] += tree[root2];
            tree[root2] = root1;
        } else {
            tree[root2] += tree[root1];
            tree[root1] = root2;
        }
        size--;
    }

    public int find(int idx) {
        if (tree[idx] < 0) return idx;
        return tree[idx] = find(tree[idx]);
    }

    public int size() {
        return size;
    }
}
```
