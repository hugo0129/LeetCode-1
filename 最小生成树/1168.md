[toc]

```java
class Solution {
    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {
        if (n <= 0) return 0;
        // 权重队列
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        for (int[] pipe : pipes) {
            queue.add(pipe);
        }
        DisJoint disJoint = new DisJoint(n, wells);
        int accept = 0;
        int weight = 0;
        while (accept < n - 1 && !queue.isEmpty()) {
            int[] cur = queue.poll();
            if (disJoint.find(cur[0] - 1) != disJoint.find(cur[1] - 1)) {
                disJoint.union(disJoint.find(cur[0] - 1), disJoint.find(cur[1] - 1));
                weight += cur[2];
                accept++;
            }
        }

        boolean[] flag = new boolean[n];
        for (int i = 0; i < n; i++) {
            int root = disJoint.find(i);
            if (flag[root]) continue;
            weight += disJoint.getMinWeight(root);
            flag[root] = true;
        }
        return weight;
    }
}

class DisJoint {
    // 带权重的不相交集，位置0表示根，位置1表示本集合最小的井的花费
    private int[][] tree;
    private int size;

    DisJoint(int size, int[] weights) {
        this.size = size;
        this.tree = new int[size][2];
        for (int i = 0; i < size; i++) {
            tree[i][0] = -1;
            tree[i][1] = weights[i];
        }
    }

    public void union(int root1, int root2) {
        if (tree[root1][0] >= 0 || tree[root2][0] >= 0) throw new IllegalArgumentException("invalid param");
        if (root1 == root2) return;

        if (tree[root1][0] <= tree[root2][0]) {
            tree[root1][0] += tree[root2][0];
            tree[root2][0] = root1;
            tree[root1][1] = Math.min(tree[root1][1], tree[root2][1]);
        } else {
            tree[root2][0] += tree[root1][0];
            tree[root1][0] = root2;
            tree[root2][1] = Math.min(tree[root1][1], tree[root2][1]);
        }
        size--;
    }

    public int find(int idx) {
        if (tree[idx][0] < 0) return idx;
        return tree[idx][0] = find(tree[idx][0]);
    }

    public int size() {
        return size;
    }

    public int getMinWeight(int idx) {
        if (tree[idx][0] < 0) return tree[idx][1];
        return getMinWeight(tree[idx][0]);
    }
}
```



```java
class Solution {
    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {
        if (n <= 0) return 0;
        // 权重队列
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        for (int[] pipe : pipes) {
            queue.add(pipe);
        }
        DisJoint disJoint = new DisJoint(n, wells);
        int accept = 0;
        int weight = 0;
        while (accept < n - 1 && !queue.isEmpty()) {
            int[] cur = queue.poll();
            int root1 = disJoint.find(cur[0] - 1);
            int root2 = disJoint.find(cur[1] - 1);
            if (root1 != root2 && Math.max(disJoint.getMinWeight(root1), disJoint.getMinWeight(root2)) >= cur[2]) {
                disJoint.union(root1, root2);
                weight += cur[2];
                accept++;
            }
        }

        boolean[] flag = new boolean[n];
        for (int i = 0; i < n; i++) {
            int root = disJoint.find(i);
            if (flag[root]) continue;
            weight += disJoint.getMinWeight(root);
            flag[root] = true;
        }
        return weight;
    }
}

class DisJoint {
    // 带权重的不相交集，位置0表示根，位置1表示本集合最小的井的花费
    private int[][] tree;
    private int size;

    DisJoint(int size, int[] weights) {
        this.size = size;
        this.tree = new int[size][2];
        for (int i = 0; i < size; i++) {
            tree[i][0] = -1;
            tree[i][1] = weights[i];
        }
    }

    public void union(int root1, int root2) {
        if (tree[root1][0] >= 0 || tree[root2][0] >= 0) throw new IllegalArgumentException("invalid param");
        if (root1 == root2) return;

        if (tree[root1][0] <= tree[root2][0]) {
            tree[root1][0] += tree[root2][0];
            tree[root2][0] = root1;
            tree[root1][1] = Math.min(tree[root1][1], tree[root2][1]);
        } else {
            tree[root2][0] += tree[root1][0];
            tree[root1][0] = root2;
            tree[root2][1] = Math.min(tree[root1][1], tree[root2][1]);
        }
        size--;
    }

    public int find(int idx) {
        if (tree[idx][0] < 0) return idx;
        return tree[idx][0] = find(tree[idx][0]);
    }

    public int size() {
        return size;
    }

    public int getMinWeight(int idx) {
        if (tree[idx][0] < 0) return tree[idx][1];
        return getMinWeight(tree[idx][0]);
    }
}
```

