[toc]

```java
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        if (n <= 0) throw new IllegalArgumentException("invalid param");

        Node[] graph = new Node[n];
        for (int[] edge : red_edges) {
            graph[edge[0]] = new Node(edge[1], 0, graph[edge[0]]);
        }
        for (int[] edge : blue_edges) {
            graph[edge[0]] = new Node(edge[1], 1, graph[edge[0]]);
        }

        // 距离和前驱，及记录路径颜色
        int[] distance = new int[n];
        int[] prev = new int[n];
        // 记录当前结点在路径中的入边的颜色
        int[] color = new int[n];
        boolean[] flag = new boolean[n];
        Arrays.fill(distance, -1);

        // 初始化起点，起点没有入边，颜色置为-1
        distance[0] = 0;
        prev[0] = 0;
        color[0] = -1;

        for (int i = 0; i < n - 1; i++) {
            // 查找当前的最小距离
            int minIdx = -1;
            for (int j = 0; j < n; j++) {
                if (!flag[j] && distance[j] != -1 && (minIdx == -1 || distance[j] < distance[minIdx])) minIdx = j;
            }
            // 无法连通剩余的结点，退出
            if (minIdx == -1) break;
            // 加入路径
            flag[minIdx] = true;

            int col = color[minIdx];
            // 遍历miniDx出边
            Node temp = graph[minIdx];
            while (temp != null) {
                if (!flag[temp.ver] && temp.color != col && (distance[temp.ver] == -1
                        || distance[temp.ver] > distance[minIdx] + 1)) {
                    distance[temp.ver] = distance[minIdx] + 1;
                    prev[temp.ver] = minIdx;
                    color[temp.ver] = temp.color;
                }

                temp = temp.next;
            }
        }

        return distance;
    }
}

class Node {
    int ver;
    int color;
    Node next;

    Node(int ver, int color, Node next) {
        this.ver = ver;
        this.color = color;
        this.next = next;
    }
}
```



[[0,1],[1,2],[2,3],[3,4]]
					[[1,2],[2,3],[3,1]]



```java
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        if (n <= 0) throw new IllegalArgumentException("invalid param");

        Node[] graph = new Node[n];
        for (int[] edge : red_edges) {
            graph[edge[0]] = new Node(edge[1], 0, graph[edge[0]]);
        }
        for (int[] edge : blue_edges) {
            graph[edge[0]] = new Node(edge[1], 1, graph[edge[0]]);
        }

        // 距离
        int[] distance = new int[n];
        Arrays.fill(distance, -1);

        Queue<int[]> queue = new LinkedList<>();
        // 当前结点、累计路径长度、颜色
        queue.add(new int[]{0 ,0, -1});
        distance[0] = 0;

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();

            int color = cur[2];
            Node next = graph[cur[0]];
            Node pre = null;
            while (next != null) {
                // 更新
                if (color != next.color) {
                    if (distance[next.ver] == -1 || distance[next.ver] > cur[1] + 1) distance[next.ver] = cur[1] + 1;
                    if (pre == null) {
                        graph[cur[0]] = next.next;
                    } else {
                        pre.next = next.next;
                    }
                    queue.add(new int[]{next.ver, cur[1] + 1, next.color});
                }
                pre = next;
                next = next.next;
            }
        }

        return distance;
    }
}

class Node {
    int ver;
    int color;
    Node next;

    Node(int ver, int color, Node next) {
        this.ver = ver;
        this.color = color;
        this.next = next;
    }
}
```

