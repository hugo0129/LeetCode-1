[toc]

```java
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // 边少于连通的最低要求
        if (times == null || times.length < N - 1) return -1;

        // 构建图
        Node[] graph = new Node[N];
        for (int[] time : times) {
            graph[time[0] - 1] = new Node(time[1] - 1, time[2], graph[time[0] - 1]);
        }
        // 距离及前驱
        int[] distance = new int[N];
        int[] prev = new int[N];
        // 是否加入最短路径
        boolean[] flag = new boolean[N];
        // 初始化起始结点
        prev[K - 1] = K - 1;
        Arrays.fill(distance, Integer.MAX_VALUE);
        distance[K - 1] = 0;
        // 遍历N - 1次
        for (int i = 0; i < N - 1; i++) {
            // 查找当前未加入路径的最小距离
            int minIdx = -1;
            for (int j = 0; j < N; j++) {
                if (!flag[j] && (minIdx == -1 || distance[j] < distance[minIdx])) minIdx = j;
            }
            // 加入路径
            flag[minIdx] = true;
            // 更新后继结点距离
            Node temp = graph[minIdx];
            while (temp != null) {
                // 如果有更短的路径，更新距离及前驱
                if (!flag[temp.ver] && distance[minIdx] + temp.weight < distance[temp.ver]) {
                    distance[temp.ver] = distance[minIdx] + temp.weight;
                    prev[temp.ver] = minIdx;
                }
                temp = temp.next;
            }
        }
        int maxDis = 0;
        for (int dis : distance) {
            maxDis = Math.max(maxDis, dis);
        }
        // 如果还有距离是不可达，则返回-1，否则返回最大值
        return maxDis == Integer.MAX_VALUE ? -1 : maxDis;
    }
}

class Node {
    int ver;
    int weight;
    Node next;

    Node(int ver, int weight, Node next) {
        this.ver = ver;
        this.weight = weight;
        this.next = next;
    }
}
```



```java
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // 边少于连通的最低要求
        if (times == null || times.length < N - 1) return -1;

        // 构建图
        Node[] graph = new Node[N];
        for (int[] time : times) {
            graph[time[0] - 1] = new Node(time[1] - 1, time[2], graph[time[0] - 1]);
        }

        // 距离及前驱
        int[] prev = new int[N];
        int[] distance = new int[N];
        Arrays.fill(distance, Integer.MAX_VALUE);
        // 是否加入最短路径
        boolean[] flag = new boolean[N];

        // 保存数组。第一个位置为终点索引，第二个位置为前驱，第三个位置为到起点距离
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        queue.add(new int[]{K - 1, K - 1, 0});

        // 遍历N次
        for (int i = 0; i < N; i++) {
            // 出队已加入路径的点
            while (!queue.isEmpty() && flag[queue.peek()[0]]) {
                queue.poll();
            }
            if (queue.isEmpty()) return -1;
            // 查找当前未加入路径的最小距离
            int[] cur = queue.poll();
            int curIdx = cur[0], curPre = cur[1], curDis = cur[2];

            // 加入路径
            flag[curIdx] = true;
            distance[curIdx] = curDis;
            prev[curIdx] = curPre;

            // 更新后继结点距离
            Node temp = graph[curIdx];
            while (temp != null) {
                // 如果有更短的路径，更新距离及前驱
                if (!flag[temp.ver]) {
                   queue.add(new int[]{temp.ver, curIdx, curDis + temp.weight});
                }
                temp = temp.next;
            }
        }
        int maxDis = 0;
        for (int dis : distance) {
            System.out.println(dis);
            maxDis = Math.max(maxDis, dis);
        }
        // 如果还有距离是不可达，则返回-1，否则返回最大值
        return maxDis == Integer.MAX_VALUE ? -1 : maxDis;
    }
}

class Node {
    int ver;
    int weight;
    Node next;

    Node(int ver, int weight, Node next) {
        this.ver = ver;
        this.weight = weight;
        this.next = next;
    }
}
```

