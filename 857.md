[toc]

```java
class Solution {
    public double mincostToHireWorkers(int[] quality, int[] wage, int K) {
        if(quality == null || quality.length < K || quality.length != wage.length) {
            throw new IllegalArgumentException("invalid param");
        }
        // 索引数组
        Integer[] index = new Integer[quality.length];
        for (int i = 0; i < quality.length; i++) {
            index[i] = i;
        }
        // 根据薪酬效益比来排序
        Arrays.sort(index, (a, b) -> Double.compare((double)wage[a] / quality[a], (double) wage[b] / quality[b]));
        // 最大堆，根据效益排序
        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> quality[b] - quality[a]);
        int quaSum = 0;
        double res = Double.MAX_VALUE;
        // idx的工人取最低薪资，其前的工人都可以满足薪资要求（由于薪酬效益比小于当前工人，薪资必然比最低薪资大）
        for(int idx : index) {
            // 加入队列，同时总的效益增加
            queue.add(idx);
            quaSum += quality[idx];
            // 超过K个人，删除效益最大的人（必然薪资也是最大的）
            // 此处可以会将当前入队的工人删除，没关系，因为此时的总薪酬必然不是最小（K个人，每个人薪资都超过最低薪资），不会更新到最终结果
            if(queue.size() > K) {
                quaSum -= quality[queue.poll()];
            }
            // 正好K个人，计算总的薪资
            if(queue.size() == K) {
                res = Math.min(res, quaSum * (double)wage[idx] / quality[idx]);
            }
        }
        return res;
    }
}
```
