[toc]

```java
class Solution {
    public int nthUglyNumber(int n, int a, int b, int c) {
        if (n < 1 || a < 1 || b < 1 || c < 1) throw new IllegalArgumentException("invalid param");
        // 第n个丑数不超过max
        int max = Math.min(Math.min(a, b), c) * n;
        // 记录前一个出队的值，防止重复
        int pre = -1;
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        queue.add(a);
        queue.add(b);
        queue.add(c);
        while (n > 0 && !queue.isEmpty()) {
            int cur = queue.poll();
            // 重复值
            if (pre != -1 && pre == cur) {
                continue;
            }
            // 扩展栈
            if (cur % a == 0 && cur + a <= max) queue.add(cur + a);
            if (cur % b == 0 && cur + b <= max) queue.add(cur + b);
            if (cur % c == 0 && cur + c <= max) queue.add(cur + c);
            pre = cur;
            n--;
        }
        return pre;
    }
}
```



```java
class Solution {
    public int nthUglyNumber(int n, int a, int b, int c) {
        if (n < 1 || a < 1 || b < 1 || c < 1) throw new IllegalArgumentException("invalid param");
        // 两两组合的最小公倍数
        long lcmAB = lcm(a, b);
        long lcmAC = lcm(a, c);
        long lcmBC = lcm(b, c);
        // 三个数的最小公倍数
        long lcm = lcm(lcmAB, c);
        // lcm之内的数字数目
        long m = lcm / a + lcm / b + lcm / c - lcm / lcmAB - lcm / lcmAC - lcm / lcmBC + 1;

        long epoch = n / m;
        long r = n % m;
        long result = epoch * lcm;

        if (r > 0) {
            // 二分查找，范围缩小为1～lcm
            long left = 1, right = lcm;
            while (left < right) {
                long mid = left + (right - left) / 2;
                long count = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmAC - mid / lcmBC + mid / lcm;
                if (count >= r) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            // 最后left就是要查找的值
            result += left;
        }

        return (int)result;
    }
    // 最小公倍数
    private long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }
    // 最大公因数
    private long gcd(long x, long y) {
        if (x == 0) return y;
        return gcd(y % x, x);
    }
}
```

