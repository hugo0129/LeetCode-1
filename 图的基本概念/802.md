[toc]

```java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        List<Integer> res = new LinkedList<>();
        // 不存在顶点
        if(graph == null || graph.length == 0) return res;

        int n = graph.length;
        // 标记访问，-1表示已遍历，无环，-2表示有环，0表示未遍历，1表示再遍历
        int[] visited = new int[n];

        for (int i = 0; i < n; i++) {
            if (visited[i] == 0) dfs(i, graph, visited);
        }

        for (int i = 0; i < n; i++) {
            if (visited[i] == -1) res.add(i);
        }
        return res;
    }

    private int dfs(int start, int[][] graph, int[] visited) {
        // 有环
        if (visited[start] == 1) {
            visited[start] = -2;
        }
        // 已经有遍历结果，返回
        if (visited[start] != 0) {
            return visited[start];
        }
        // 标记为已访问
        visited[start] = 1;
        // 访问后继结点
        for (int i = 0; i < graph[start].length; i++) {
            int cur = graph[start][i];
            int result = dfs(cur, graph, visited);
            // 如果存在环，则设置当前路径状态为-2，不结束遍历，继续其他分支遍历
            if (result != -1) {
                visited[start] = result;
            }
        }
        // 完成遍历，后续路径不存在环，故此处还是i，赋值为-1，返回
        if (visited[start] == 1) visited[start] = -1;
        return visited[start];
    }
}
```
