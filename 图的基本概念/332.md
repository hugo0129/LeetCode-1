[toc]

```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        List<String> res = new LinkedList<>();
        if (tickets == null || tickets.size() == 0) return res;

        // 结点集
        Set<String> verName = new HashSet<>();
        for (List<String> ticket : tickets) {
            verName.add(ticket.get(0));
            verName.add(ticket.get(1));
        }
        int verNum = verName.size();
        // 根据结点字母序排序，方便后面搜索先搜索排序靠前的结点
        String[] verIdx = verName.toArray(new String[verNum]);
        Arrays.sort(verIdx);
        // 结点名称索引映射
        Map<String, Integer> idxMap = new HashMap<>();
        for (int i = 0; i < verNum; i++) {
            idxMap.put(verIdx[i], i);
        }

        // 边数
        int edgeNum = 0;
        // 边集
        int[][] graph = new int[verNum][verNum];
        for (List<String> ticket : tickets) {
            int start = idxMap.get(ticket.get(0));
            int end = idxMap.get(ticket.get(1));
            if (graph[start][end] == 0) {
                graph[start][end] = 1;
                edgeNum++;
            }
        }
        // 从JFK出发深度优先搜索
        boolean flag = findPath(idxMap.get("JFK"), graph, edgeNum, verIdx, res);
        if (!flag) throw new IllegalArgumentException("error graph");
        Collections.reverse(res);
        return res;
    }

    private boolean findPath(int start, int[][] graph, int edgeNum, String[] verIdx, List<String> res) {
        // 当前结点start是否不存在出边
        boolean flag = true;
        for (int i = 0; i < graph.length; i++) {
            // 存在边则遍历
            if (graph[start][i] == 1) {
                flag = false;
                // 已遍历该边，标记为0断开
                graph[start][i] = 0;
                // 后继结点遍历完所有的边，路径存在，添加当前结点，返回
                if (findPath(i, graph, edgeNum - 1, verIdx, res)) {
                    res.add(verIdx[start]);
                    return true;
                }
                // 后继结点无法遍历完所有的边，重新连接边
                graph[start][i] = 1;
            }
        }
        // 当前结点不存在出边且总的可遍历边数为0，表示找到路径，且当前结点是最终结点
        if (flag && edgeNum == 0) {
            res.add(verIdx[start]);
            return true;
        }
        return false;
    }
}
```

[["EZE","AXA"],["TIA","ANU"],["ANU","JFK"],["JFK","ANU"],["ANU","EZE"],["TIA","ANU"],["AXA","TIA"],["TIA","JFK"],["ANU","TIA"],["JFK","TIA"]]

```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        List<String> res = new LinkedList<>();
        if (tickets == null || tickets.size() == 0) return res;

        // 结点集
        Set<String> verName = new HashSet<>();
        for (List<String> ticket : tickets) {
            verName.add(ticket.get(0));
            verName.add(ticket.get(1));
        }
        int verNum = verName.size();
        // 根据结点字母序排序，方便后面搜索先搜索排序靠前的结点
        String[] verIdx = verName.toArray(new String[verNum]);
        Arrays.sort(verIdx);
        // 结点名称索引映射
        Map<String, Integer> idxMap = new HashMap<>();
        for (int i = 0; i < verNum; i++) {
            idxMap.put(verIdx[i], i);
        }

        // 边数
        int edgeNum = 0;
        // 边集
        int[][] graph = new int[verNum][verNum];
        for (List<String> ticket : tickets) {
            int start = idxMap.get(ticket.get(0));
            int end = idxMap.get(ticket.get(1));
            graph[start][end]++;
            edgeNum++;
        }
        // 从JFK出发深度优先搜索
        boolean flag = findPath(idxMap.get("JFK"), graph, edgeNum, verIdx, res);
        if (!flag) throw new IllegalArgumentException("error graph");
        Collections.reverse(res);
        return res;
    }

    private boolean findPath(int start, int[][] graph, int edgeNum, String[] verIdx, List<String> res) {
        // 当前结点start是否不存在出边
        boolean flag = true;
        for (int i = 0; i < graph.length; i++) {
            // 存在边则遍历
            if (graph[start][i] > 0) {
                flag = false;
                // 已遍历该边，标记为0断开
                graph[start][i]--;
                // 后继结点遍历完所有的边，路径存在，添加当前结点，返回
                if (findPath(i, graph, edgeNum - 1, verIdx, res)) {
                    res.add(verIdx[start]);
                    return true;
                }
                // 后继结点无法遍历完所有的边，重新连接边
                graph[start][i]++;
            }
        }
        // 当前结点不存在出边且总的可遍历边数为0，表示找到路径，且当前结点是最终结点
        if (flag && edgeNum == 0) {
            res.add(verIdx[start]);
            return true;
        }
        return false;
    }
}
```



```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        List<String> res = new LinkedList<>();
        if (tickets == null || tickets.size() == 0) return res;

        // 结点集
        Set<String> verName = new HashSet<>();
        for (List<String> ticket : tickets) {
            verName.add(ticket.get(0));
            verName.add(ticket.get(1));
        }
        int verNum = verName.size();
        // 根据结点字母序排序，方便后面搜索先搜索排序靠前的结点
        String[] verIdx = verName.toArray(new String[verNum]);
        Arrays.sort(verIdx);
        // 结点名称索引映射
        Map<String, Integer> idxMap = new HashMap<>();
        for (int i = 0; i < verNum; i++) {
            idxMap.put(verIdx[i], i);
        }

        // 边数
        int edgeNum = tickets.size();
        // 边集
        Node[] graph = new Node[verNum];
        for (List<String> ticket : tickets) {
            int start = idxMap.get(ticket.get(0));
            int end = idxMap.get(ticket.get(1));
            // 插入保持索引的有序性
            if (graph[start] == null || graph[start].val >= end) {
                graph[start] = new Node(end, graph[start]);
            } else {
                Node pre = null;
                Node temp = graph[start];
                while (temp != null && temp.val < end) {
                    pre = temp;
                    temp = temp.next;
                }
                pre.next = new Node(end, temp);
            }
        }
        // 从JFK出发深度优先搜索
        boolean flag = findPath(idxMap.get("JFK"), graph, edgeNum, verIdx, res);
        // 不存在可行路径
        if (!flag) throw new IllegalArgumentException("error graph");
        Collections.reverse(res);
        return res;
    }

    private boolean findPath(int start, Node[] graph, int edgeNum, String[] verIdx, List<String> res) {
        // 当前结点start是否不存在出边
        boolean flag = true;
        Node temp = graph[start];
        Node pre = null;
        while (temp != null) {
            flag = false;
            // 暂时删除
            if (pre != null) {
                pre.next = temp.next;
            } else {
                graph[start] = temp.next;
            }
            // 后继结点遍历完所有的边，路径存在，添加当前结点，返回
            if (findPath(temp.val, graph, edgeNum - 1, verIdx, res)) {
                res.add(verIdx[start]);
                return true;
            }
            // 插入保持有序性，插入到原来位置
            if (pre == null) {
                temp.next = graph[start];
                graph[start] = temp;
            } else {
                temp.next = pre.next;
                pre.next = temp;
            }
            pre = temp;
            temp = temp.next;
        }

        // 当前结点不存在出边且总的可遍历边数为0，表示找到路径，且当前结点是最终结点
        if (flag && edgeNum == 0) {
            res.add(verIdx[start]);
            return true;
        }
        return false;
    }
}

class Node {
    int val;
    Node next;

    Node(int val) {
        this.val = val;
    }

    Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }
}
```



```java
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        List<String> res = new LinkedList<>();
        if (tickets == null || tickets.size() == 0) return res;

        // 结点集
        Set<String> verName = new HashSet<>();
        for (List<String> ticket : tickets) {
            verName.add(ticket.get(0));
            verName.add(ticket.get(1));
        }
        int verNum = verName.size();
        // 根据结点字母序排序，方便后面搜索先搜索排序靠前的结点
        String[] verIdx = verName.toArray(new String[verNum]);
        Arrays.sort(verIdx);
        // 结点名称索引映射
        Map<String, Integer> idxMap = new HashMap<>();
        for (int i = 0; i < verNum; i++) {
            idxMap.put(verIdx[i], i);
        }

        // 边数
        int edgeNum = tickets.size();
        // 边集
        Node[] graph = new Node[verNum];
        for (List<String> ticket : tickets) {
            int start = idxMap.get(ticket.get(0));
            int end = idxMap.get(ticket.get(1));
            // 插入保持索引的有序性
            if (graph[start] == null || graph[start].val >= end) {
                graph[start] = new Node(end, graph[start]);
            } else {
                Node pre = null;
                Node temp = graph[start];
                while (temp != null && temp.val < end) {
                    pre = temp;
                    temp = temp.next;
                }
                pre.next = new Node(end, temp);
            }
        }
        List<String> last = new LinkedList<>();
        int start = idxMap.get("JFK");
        int count = 0;
        // 从JFK出发深度优先搜索
        while (graph[start] != null) {
            int next = graph[start].val;
            // 删除当前边
            graph[start] = graph[start].next;
            List<String> path = new LinkedList<>();
            path.add(verIdx[start]);
            dfs(next, start, graph, verIdx, path);
            if (path.get(path.size() - 1).equals("JFK")) {
                res.addAll(path.subList(0, path.size() - 1));
            } else {
                last.addAll(path);
            }
        }
        if (last.isEmpty()) {
            res.add(verIdx[start]);
        } else {
            res.addAll(last);
        }
        return res;
    }

    private void dfs(int start, int end, Node[] graph, String[] verIdx, List<String> path) {
        // 加入当前结点
        path.add(verIdx[start]);
        if (start != end && graph[start] != null) {
            int next = graph[start].val;
            // 删除边（由于是有序的，只需头结点后移）
            graph[start] = graph[start].next;
            dfs(next, end, graph, verIdx, path);
        }
    }
}

class Node {
    int val;
    Node next;

    Node(int val) {
        this.val = val;
    }

    Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }
}
```

